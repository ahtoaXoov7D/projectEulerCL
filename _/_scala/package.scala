package fjab

import scala.annotation.tailrec
import scala.math.BigInt

package object euler {

  def isPalindrome(n: Int) = n.toString.reverse.toInt == n

  def ceiling(x:Int, n:Int): Int = (x + n - 1)/n
  def ceiling2(x:Int, n:Int): Int = x%n match {
    case 0 => x/n
    case _ => x/n + 1
  }
  def floor(x:Int, n:Int): Int = x/n

  /**
    * Given a number of elements and a number of groups, this method distributes the elements among the groups.
    * If numElements is a multiple of numGroups, the elements are equally divided.
    * If numElements is not a multiple of numGroups, all the groups except the last one will have the same number
    * of elements. For instance, if numElements=8 and numGroups=3, there will be 2 groups with 3 elements and 1 with 2.
    *
    * It returns a sequence of 3-element tuples. Each tuple represent a group and contains the following information:
    * - id of the group (0.... numGroups-1)
    * - id of the first element of the group (a value from 0 to numElements-1)
    * - id of the last element of the group (a value from 0 to numElements-1)
    *
    * The following condition must be true, otherwise the method will throw an exception : numElements >= numGroups
    *
    */
  def groups(numElements: Int, numGroups: Int): Seq[(Int, Int, Int)] = {
    if(numGroups > numElements) throw new IllegalArgumentException("numElements must be greater or equal than numGroups")
    val numElementsPerGroup = ceiling(numElements,numGroups)
    for(j <- 0 until numGroups)
      yield (j, j*numElementsPerGroup, math.min((j+1)*numElementsPerGroup-1,numElements-1))
  }

  /**
    * The sequence of triangle numbers is generated by adding the natural numbers.
    * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
    * The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    */
  def triangleNumbersGenerator: Stream[BigInt] = {
    def arithmeticSum(n: BigInt) = n * (n + 1) / 2
    def numbersGenerator(n: BigInt): Stream[BigInt] =arithmeticSum(n) #:: numbersGenerator(n + 1)
    1 #:: numbersGenerator(2)
  }

  def collatzSequenceGenerator(n: BigInt): Stream[BigInt] = (n/2)*2 match{
    case `n` => n #:: collatzSequenceGenerator(n/2)
    case _ => n #:: collatzSequenceGenerator(3*n+1)
  }

  /**
    *  Elements of the Collatz sequence are defined as:
    *  n → n/2 (n is even)
    *  n → 3n + 1 (n is odd)
    *
    * Using the rule above and starting with 13, we generate the following sequence:
    * 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
    *
    *  it is thought that all starting numbers finish at 1
    *
    */
  def collatzSeries(n: Int): List[BigInt] = {

    val iter = collatzSequenceGenerator(n).iterator
    def loop(m:BigInt, s: List[BigInt]): List[BigInt] = if(m == 1) m :: s else loop(iter.next(), m :: s)
    loop(iter.next(), Nil).reverse
  }

  def decimalRepresentation(n: BigInt): List[BigInt] = {
    val q = n/10
    val r = n%10
    if(q == 0) List(r)
    else r :: decimalRepresentation(q)
  }

  def decimalRepresentationTailRecursive(n: BigInt): List[BigInt] = {

    @tailrec
    def acc(n: BigInt, representation: List[BigInt]): List[BigInt] = {
      val q = n/10
      val r = n%10
      if(q == 0) r :: representation
      else acc(q, r :: representation)
    }

    acc(n, Nil)
  }

  def countDigits(n: Int) = n.toString.length

  def countDigitsRecursive(n: Int): Int =
    if(n/10 == 0) 1
    else 1 + countDigitsRecursive(n/10)

  def countDigitsTailRecursive(n: Int) = {
    @tailrec
    def acc(n: Int, counter: Int): Int = {
      val x = n/10
      if(x == 0) counter + 1
      else acc(x, counter + 1)
    }
    acc(n,0)
  }

  /**
    * Rotate the elements of seq i places to the left
    *
    * (1,2,3,4,5) becomes (3,4,5,1,2) when rotated 2 places to the left
    */
  def rotateLeft[A](seq: Seq[A], i: Int): Seq[A] = {
    val size = seq.size
    seq.drop(i % size) ++ seq.take(i % size)
  }
}
